//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g 2012-02-15 14:28:50

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System.Collections;
	using System;
	using System.Collections.Generic;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  ChemProV.Grammars 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class ChemProVTree : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "FLOAT", "IDENTIFIER", "INTEGER", "NEWLINE", "VAR", "WS", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "'='", "'let'"
	};
	public const int EOF=-1;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int FLOAT=4;
	public const int IDENTIFIER=5;
	public const int INTEGER=6;
	public const int NEWLINE=7;
	public const int VAR=8;
	public const int WS=9;

	public ChemProVTree(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ChemProVTree(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ChemProVTree.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g"; } }


		public List<ChemProVLine> lines = new List<ChemProVLine>();
		private int currentLineNumber = 0;


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:21:8: public program : ( line )+ ;
	[GrammarRule("program")]
	public void program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(21, 1);
		try
		{
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:22:2: ( ( line )+ )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:22:5: ( line )+
			{
			DebugLocation(22, 5);
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:22:5: ( line )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==VAR||LA1_0==16))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:22:6: line
					{
					DebugLocation(22, 6);
					PushFollow(Follow._line_in_program55);
					line();
					PopFollow();

					DebugLocation(23, 2);

							currentLineNumber++;
						

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(26, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return;

	}
	// $ANTLR end "program"

	partial void EnterRule_line();
	partial void LeaveRule_line();

	// $ANTLR start "line"
	// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:28:1: line : ( variable | balance );
	[GrammarRule("line")]
	private void line()
	{
		EnterRule_line();
		EnterRule("line", 2);
		TraceIn("line", 2);
		try { DebugEnterRule(GrammarFileName, "line");
		DebugLocation(28, 1);
		try
		{
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:29:2: ( variable | balance )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==VAR))
			{
				alt2 = 1;
			}
			else if ((LA2_0==16))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:29:4: variable
				{
				DebugLocation(29, 4);
				PushFollow(Follow._variable_in_line73);
				variable();
				PopFollow();

				DebugLocation(29, 13);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:30:4: balance
				{
				DebugLocation(30, 4);
				PushFollow(Follow._balance_in_line80);
				balance();
				PopFollow();

				DebugLocation(30, 12);


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("line", 2);
			LeaveRule("line", 2);
			LeaveRule_line();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "line"); }
		return;

	}
	// $ANTLR end "line"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();

	// $ANTLR start "variable"
	// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:33:1: variable : ^( VAR IDENTIFIER computation ) ;
	[GrammarRule("variable")]
	private void variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(33, 1);
		try
		{
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:34:2: ( ^( VAR IDENTIFIER computation ) )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:34:4: ^( VAR IDENTIFIER computation )
			{
			DebugLocation(34, 4);
			DebugLocation(34, 6);
			Match(input,VAR,Follow._VAR_in_variable94); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(34, 10);
			Match(input,IDENTIFIER,Follow._IDENTIFIER_in_variable96); 
			DebugLocation(34, 21);
			PushFollow(Follow._computation_in_variable98);
			computation();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(35, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return;

	}
	// $ANTLR end "variable"

	partial void EnterRule_balance();
	partial void LeaveRule_balance();

	// $ANTLR start "balance"
	// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:37:1: balance : ^( '=' computation computation ) ;
	[GrammarRule("balance")]
	private void balance()
	{
		EnterRule_balance();
		EnterRule("balance", 4);
		TraceIn("balance", 4);
		try { DebugEnterRule(GrammarFileName, "balance");
		DebugLocation(37, 1);
		try
		{
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:38:2: ( ^( '=' computation computation ) )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:38:4: ^( '=' computation computation )
			{
			DebugLocation(38, 4);
			DebugLocation(38, 6);
			Match(input,16,Follow._16_in_balance112); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(38, 10);
			PushFollow(Follow._computation_in_balance114);
			computation();
			PopFollow();

			DebugLocation(38, 22);
			PushFollow(Follow._computation_in_balance116);
			computation();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(38, 35);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("balance", 4);
			LeaveRule("balance", 4);
			LeaveRule_balance();
		}
		DebugLocation(39, 1);
		} finally { DebugExitRule(GrammarFileName, "balance"); }
		return;

	}
	// $ANTLR end "balance"

	private sealed partial class computation_return : TreeRuleReturnScope<CommonTree>
	{
		public int token;
		public int value;
		public computation_return(ChemProVTree grammar) {OnCreated(grammar);}
		partial void OnCreated(ChemProVTree grammar);
	}

	partial void EnterRule_computation();
	partial void LeaveRule_computation();

	// $ANTLR start "computation"
	// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:41:1: computation returns [int token, int value] : ( ^( '+' left= computation right= computation ) | ^( '-' left= computation right= computation ) | ^( '*' left= computation right= computation ) | ^( '/' left= computation right= computation ) | IDENTIFIER | INTEGER | FLOAT );
	[GrammarRule("computation")]
	private ChemProVTree.computation_return computation()
	{
		EnterRule_computation();
		EnterRule("computation", 5);
		TraceIn("computation", 5);
		ChemProVTree.computation_return retval = new ChemProVTree.computation_return(this);
		retval.Start = (CommonTree)input.LT(1);

		CommonTree IDENTIFIER1 = default(CommonTree);
		CommonTree INTEGER2 = default(CommonTree);
		CommonTree FLOAT3 = default(CommonTree);
		ChemProVTree.computation_return left = default(ChemProVTree.computation_return);
		ChemProVTree.computation_return right = default(ChemProVTree.computation_return);

		try { DebugEnterRule(GrammarFileName, "computation");
		DebugLocation(41, 1);
		try
		{
			// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:42:2: ( ^( '+' left= computation right= computation ) | ^( '-' left= computation right= computation ) | ^( '*' left= computation right= computation ) | ^( '/' left= computation right= computation ) | IDENTIFIER | INTEGER | FLOAT )
			int alt3=7;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case 13:
				{
				alt3 = 1;
				}
				break;
			case 14:
				{
				alt3 = 2;
				}
				break;
			case 12:
				{
				alt3 = 3;
				}
				break;
			case 15:
				{
				alt3 = 4;
				}
				break;
			case IDENTIFIER:
				{
				alt3 = 5;
				}
				break;
			case INTEGER:
				{
				alt3 = 6;
				}
				break;
			case FLOAT:
				{
				alt3 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:42:4: ^( '+' left= computation right= computation )
				{
				DebugLocation(42, 4);
				DebugLocation(42, 6);
				Match(input,13,Follow._13_in_computation136); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(42, 14);
				PushFollow(Follow._computation_in_computation140);
				left=computation();
				PopFollow();

				DebugLocation(42, 32);
				PushFollow(Follow._computation_in_computation144);
				right=computation();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(42, 46);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:43:4: ^( '-' left= computation right= computation )
				{
				DebugLocation(43, 4);
				DebugLocation(43, 6);
				Match(input,14,Follow._14_in_computation153); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(43, 14);
				PushFollow(Follow._computation_in_computation157);
				left=computation();
				PopFollow();

				DebugLocation(43, 32);
				PushFollow(Follow._computation_in_computation161);
				right=computation();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(43, 46);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:44:4: ^( '*' left= computation right= computation )
				{
				DebugLocation(44, 4);
				DebugLocation(44, 6);
				Match(input,12,Follow._12_in_computation170); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(44, 14);
				PushFollow(Follow._computation_in_computation174);
				left=computation();
				PopFollow();

				DebugLocation(44, 32);
				PushFollow(Follow._computation_in_computation178);
				right=computation();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(44, 46);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:45:4: ^( '/' left= computation right= computation )
				{
				DebugLocation(45, 4);
				DebugLocation(45, 6);
				Match(input,15,Follow._15_in_computation187); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(45, 14);
				PushFollow(Follow._computation_in_computation191);
				left=computation();
				PopFollow();

				DebugLocation(45, 32);
				PushFollow(Follow._computation_in_computation195);
				right=computation();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(45, 46);


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:46:4: IDENTIFIER
				{
				DebugLocation(46, 4);
				IDENTIFIER1=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_computation203); 
				DebugLocation(47, 6);

					            if (lines.Count <= currentLineNumber)
					            {
					                lines.Add(new ChemProVLine());
					            }
					            lines[currentLineNumber].VariablesUsed.Add((IDENTIFIER1!=null?IDENTIFIER1.Text:null));
					            retval.token = (IDENTIFIER1!=null?IDENTIFIER1.Type:0);
					    

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:55:4: INTEGER
				{
				DebugLocation(55, 4);
				INTEGER2=(CommonTree)Match(input,INTEGER,Follow._INTEGER_in_computation215); 
				DebugLocation(56, 3);

							retval.token = (INTEGER2!=null?INTEGER2.Type:0);
							Int32.TryParse((INTEGER2!=null?INTEGER2.Text:null), out retval.value);
						

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\acarter\\code\\chemprov\\ChemProV\\ChemProV\\Grammars\\ChemProVTree.g:60:4: FLOAT
				{
				DebugLocation(60, 4);
				FLOAT3=(CommonTree)Match(input,FLOAT,Follow._FLOAT_in_computation225); 
				DebugLocation(61, 3);

							retval.token = (FLOAT3!=null?FLOAT3.Type:0);
						

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("computation", 5);
			LeaveRule("computation", 5);
			LeaveRule_computation();
		}
		DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "computation"); }
		return retval;

	}
	// $ANTLR end "computation"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _line_in_program55 = new BitSet(new ulong[]{0x10102UL});
		public static readonly BitSet _variable_in_line73 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _balance_in_line80 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variable94 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_variable96 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_variable98 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _16_in_balance112 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _computation_in_balance114 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_balance116 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _13_in_computation136 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _computation_in_computation140 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_computation144 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _14_in_computation153 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _computation_in_computation157 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_computation161 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _12_in_computation170 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _computation_in_computation174 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_computation178 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _15_in_computation187 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _computation_in_computation191 = new BitSet(new ulong[]{0xF070UL});
		public static readonly BitSet _computation_in_computation195 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IDENTIFIER_in_computation203 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_computation215 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_computation225 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  ChemProV.Grammars 
